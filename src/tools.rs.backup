use crate::session::SessionStore;
use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use sha2::{Digest, Sha256};
use std::any::Any;
use std::collections::HashMap;
use std::io::Write as _;
use tokio::io::AsyncWriteExt;
use tokio::process::Command;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCall {
    pub name: String,
    pub arguments: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCall {
    pub id: String,
    pub r#type: String,
    pub function: FunctionCall,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Function {
    pub name: String,
    pub description: String,
    pub parameters: Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tool {
    pub r#type: String,
    pub function: Function,
}

#[async_trait]
pub trait ToolExecutor: Send + Sync {
    fn name(&self) -> &str;
    async fn execute(&self, args: &str) -> Result<String>;
}

// Example built-in tools

pub struct ShellTool;

#[async_trait]
impl ToolExecutor for ShellTool {
    fn name(&self) -> &str {
        "shell"
    }

    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let command = params["command"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing command parameter"))?;

        let output = Command::new("sh").arg("-c").arg(command).output().await?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        Ok(format!("stdout:\n{}\nstderr:\n{}", stdout, stderr))
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct CalculatorTool;

#[async_trait]
impl ToolExecutor for CalculatorTool {
    fn name(&self) -> &str {
        "calculator"
    }

    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let expression = params["expression"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing expression parameter"))?;

        // Simple calculator using bc
        let mut child = Command::new("bc")
            .arg("-l")
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .spawn()?;

        if let Some(stdin) = child.stdin.as_mut() {
            stdin.write_all(expression.as_bytes()).await?;
            stdin.write_all(b"\n").await?;
        }

        let result = child.wait_with_output().await?;
        let answer = String::from_utf8_lossy(&result.stdout).trim().to_string();

        Ok(format!("{} = {}", expression, answer))
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct FileReadTool;

#[async_trait]
impl ToolExecutor for FileReadTool {
    fn name(&self) -> &str {
        "read_file"
    }

    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path parameter"))?;
        let start_line = params
            .get("start_line")
            .and_then(|v| v.as_u64())
            .unwrap_or(1) as usize;
        let end_line = params
            .get("end_line")
            .and_then(|v| v.as_u64())
            .unwrap_or(u64::MAX) as usize;
        let max_bytes = params
            .get("max_bytes")
            .and_then(|v| v.as_u64())
            .unwrap_or(512 * 1024) as usize;

        let data = tokio::fs::read_to_string(path).await?;
        let mut out = String::new();
        for (idx, line) in data.lines().enumerate() {
            let line_no = idx + 1;
            if line_no < start_line {
                continue;
            }
            if line_no > end_line {
                break;
            }
            out.push_str(line);
            out.push('\n');
            if out.len() >= max_bytes {
                break;
            }
        }
        Ok(out)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct FileWriteTool;

#[async_trait]
impl ToolExecutor for FileWriteTool {
    fn name(&self) -> &str {
        "write_file"
    }

    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path parameter"))?;
        let content = params["content"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing content parameter"))?;
        let append = params
            .get("append")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);
        let overwrite = params
            .get("overwrite")
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        use tokio::fs::OpenOptions;
        use tokio::io::AsyncWriteExt as _;
        let mut opts = OpenOptions::new();
        opts.create(true);
        if append {
            opts.append(true);
        } else {
            opts.write(true);
        }
        if !overwrite && !append {
            // fail if file exists
            if tokio::fs::try_exists(path).await.unwrap_or(false) {
                anyhow::bail!("file exists and overwrite=false");
            }
        }
        let mut file = opts.open(path).await?;
        file.write_all(content.as_bytes()).await?;
        Ok(format!("ok: {} bytes", content.len()))
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ToolRegistry {
    tools: HashMap<String, Box<dyn ToolExecutor>>,
}

impl ToolRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            tools: HashMap::new(),
        };

        // Register default tools
        registry.register(Box::new(ShellTool));
        registry.register(Box::new(CalculatorTool));
        registry.register(Box::new(FileReadTool));
        registry.register(Box::new(FileWriteTool));
        registry.register(Box::new(ListDirTool));
        registry.register(Box::new(FindTextTool));
        registry.register(Box::new(EditFileTool));
        registry.register(Box::new(DeleteFileTool));
        registry.register(Box::new(UndeleteFileTool));
        registry.register(Box::new(GitStatusTool));
        registry.register(Box::new(GitDiffTool));
        registry.register(Box::new(GitApplyTool));
        registry.register(Box::new(HttpGetTool));
        registry.register(Box::new(HttpPostTool));
        registry.register(Box::new(FileInfoTool));
        registry.register(Box::new(ChecksumTool));
        registry.register(Box::new(JsonQueryTool));
        registry.register(Box::new(YamlQueryTool));
        registry.register(Box::new(CargoTool));
        registry.register(Box::new(FormatRustTool));
        registry.register(Box::new(ZipTool));
        registry.register(Box::new(UnzipTool));
        registry.register(Box::new(ListDeletedTool));
        registry.register(Box::new(GitCommitTool));
        registry.register(Box::new(GitBranchTool));
        registry.register(Box::new(DbQueryTool));
        registry.register(Box::new(AddNoteTool));
        registry.register(Box::new(ListNotesTool));

        registry
    }

    pub fn register(&mut self, tool: Box<dyn ToolExecutor>) {
        self.tools.insert(tool.name().to_string(), tool);
    }

    pub async fn execute(&self, name: &str, args: &str) -> Result<String> {
        self.tools
            .get(name)
            .ok_or_else(|| anyhow::anyhow!("Tool {} not found", name))?
            .execute(args)
            .await
    }

    pub fn get_tool_definitions(&self) -> Vec<Tool> {
        vec![
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "shell".to_string(),
                    description: "Execute a shell command".to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": {
                            "command": {
                                "type": "string",
                                "description": "The shell command to execute"
                            }
                        },
                        "required": ["command"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "calculator".to_string(),
                    description: "Perform mathematical calculations".to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": {
                            "expression": {
                                "type": "string",
                                "description": "Mathematical expression to evaluate"
                            }
                        },
                        "required": ["expression"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "read_file".to_string(),
                    description: "Read contents of a file (optionally a line range)".to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": {
                            "path": {
                                "type": "string",
                                "description": "Path to the file to read"
                            },
                            "start_line": {"type": "integer", "minimum": 1},
                            "end_line": {"type": "integer", "minimum": 1},
                            "max_bytes": {"type": "integer", "minimum": 1}
                        },
                        "required": ["path"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "write_file".to_string(),
                    description: "Write or append content to a file".to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": {
                            "path": {
                                "type": "string",
                                "description": "Path to the file to write"
                            },
                            "content": {
                                "type": "string",
                                "description": "Content to write to the file"
                            },
                            "append": {"type": "boolean", "default": false},
                            "overwrite": {"type": "boolean", "default": true}
                        },
                        "required": ["path", "content"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "list_dir".to_string(),
                    description: "List files in a directory".to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": {
                            "path": {"type": "string"},
                            "recursive": {"type": "boolean", "default": false},
                            "max_items": {"type": "integer", "default": 200}
                        },
                        "required": ["path"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "find_text".to_string(),
                    description: "Search text in files under a directory".to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": {
                            "root": {"type": "string"},
                            "pattern": {"type": "string"},
                            "max_results": {"type": "integer", "default": 200}
                        },
                        "required": ["root", "pattern"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "edit_file".to_string(),
                    description: "Apply a unified diff to a file".to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": {
                            "path": {"type": "string"},
                            "diff": {"type": "string", "description": "Unified diff text with @@ hunks"}
                        },
                        "required": ["path", "diff"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "delete_file".to_string(),
                    description: "Move a file to the OS recycle bin (Trash)".to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": {
                            "path": {"type": "string", "description": "Path to delete (moved to Trash)"}
                        },
                        "required": ["path"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "undelete_file".to_string(),
                    description: "Restore a previously deleted file from the CLI backup store"
                        .to_string(),
                    parameters: json!({
                        "type": "object",
                        "properties": { "path": {"type": "string"} },
                        "required": ["path"]
                    }),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "git_status".to_string(),
                    description: "Show git status (porcelain)".to_string(),
                    parameters: json!({"type":"object","properties":{},"additionalProperties":false}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "git_diff".to_string(),
                    description: "Show git diff for a rev and optional path".to_string(),
                    parameters: json!({"type":"object","properties":{"rev":{"type":"string"},"path":{"type":"string"}},"additionalProperties":false}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "git_apply".to_string(),
                    description: "Apply a unified diff via git".to_string(),
                    parameters: json!({"type":"object","properties":{"diff":{"type":"string"}},"required":["diff"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "http_get".to_string(),
                    description: "Fetch a URL (text, limited)".to_string(),
                    parameters: json!({"type":"object","properties":{"url":{"type":"string"},"max_bytes":{"type":"integer","default":262144}},"required":["url"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "http_post".to_string(),
                    description: "POST to a URL (text/JSON), return response text (limited)"
                        .to_string(),
                    parameters: json!({"type":"object","properties":{"url":{"type":"string"},"body":{"type":"string"},"content_type":{"type":"string","default":"application/json"},"max_bytes":{"type":"integer","default":262144}},"required":["url","body"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "file_info".to_string(),
                    description: "Get file info (size, mtime, type)".to_string(),
                    parameters: json!({"type":"object","properties":{"path":{"type":"string"}},"required":["path"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "checksum".to_string(),
                    description: "SHA256 checksum of a file".to_string(),
                    parameters: json!({"type":"object","properties":{"path":{"type":"string"}},"required":["path"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "json_query".to_string(),
                    description: "Query JSON file via JSON Pointer".to_string(),
                    parameters: json!({"type":"object","properties":{"path":{"type":"string"},"pointer":{"type":"string"}},"required":["path","pointer"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "yaml_query".to_string(),
                    description: "Query YAML file via JSON Pointer".to_string(),
                    parameters: json!({"type":"object","properties":{"path":{"type":"string"},"pointer":{"type":"string"}},"required":["path","pointer"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "run_cargo".to_string(),
                    description: "Run cargo with args".to_string(),
                    parameters: json!({"type":"object","properties":{"args":{"type":"string"}},"required":["args"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "format_rust".to_string(),
                    description: "Format Rust code (cargo fmt or path)".to_string(),
                    parameters: json!({"type":"object","properties":{"path":{"type":"string"}},"additionalProperties":false}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "git_commit".to_string(),
                    description: "Create a git commit; optionally add all".to_string(),
                    parameters: json!({"type":"object","properties":{"message":{"type":"string"},"add_all":{"type":"boolean","default":false}},"required":["message"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "git_branch".to_string(),
                    description: "branch ops: current|list|switch|create".to_string(),
                    parameters: json!({"type":"object","properties":{"action":{"type":"string"},"name":{"type":"string"}},"required":["action"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "zip".to_string(),
                    description: "Create a zip archive from a directory or file".to_string(),
                    parameters: json!({"type":"object","properties":{"input":{"type":"string"},"output":{"type":"string"}},"required":["input","output"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "unzip".to_string(),
                    description: "Extract a zip archive to a directory".to_string(),
                    parameters: json!({"type":"object","properties":{"archive":{"type":"string"},"output_dir":{"type":"string"}},"required":["archive","output_dir"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "list_deleted".to_string(),
                    description: "List recently deleted files recorded by the CLI".to_string(),
                    parameters: json!({"type":"object","properties":{"limit":{"type":"integer","default":50}},"additionalProperties":false}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "db_query".to_string(),
                    description: "Run a read-only SQL query against Rusty CLI DB".to_string(),
                    parameters: json!({"type":"object","properties":{"sql":{"type":"string"},"params":{"type":"array","items":{"type":["string","number","boolean","null"]}}},"required":["sql"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "add_note".to_string(),
                    description: "Add a note to the Rusty CLI DB".to_string(),
                    parameters: json!({"type":"object","properties":{"title":{"type":"string"},"content":{"type":"string"},"tags":{"type":"string"}},"required":["content"]}),
                },
            },
            Tool {
                r#type: "function".to_string(),
                function: Function {
                    name: "list_notes".to_string(),
                    description: "List recent notes (optionally filter by search)".to_string(),
                    parameters: json!({"type":"object","properties":{"search":{"type":"string"},"limit":{"type":"integer","default":50}},"additionalProperties":false}),
                },
            },
        ]
    }
}

// New tools
pub struct ListDirTool;

#[async_trait]
impl ToolExecutor for ListDirTool {
    fn name(&self) -> &str {
        "list_dir"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path"))?;
        let recursive = params
            .get("recursive")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);
        let max_items = params
            .get("max_items")
            .and_then(|v| v.as_u64())
            .unwrap_or(200) as usize;
        let mut out: Vec<String> = Vec::new();
        if recursive {
            for entry in walkdir::WalkDir::new(path).into_iter().flatten() {
                if out.len() >= max_items {
                    break;
                }
                let p = entry.path();
                out.push(p.display().to_string());
            }
        } else {
            let mut read = tokio::fs::read_dir(path).await?;
            while let Some(entry) = read.next_entry().await? {
                if out.len() >= max_items {
                    break;
                }
                out.push(entry.path().display().to_string());
            }
        }
        Ok(out.join("\n"))
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct FindTextTool;

#[async_trait]
impl ToolExecutor for FindTextTool {
    fn name(&self) -> &str {
        "find_text"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let root = params["root"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing root"))?;
        let pattern = params["pattern"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing pattern"))?;
        let max_results = params
            .get("max_results")
            .and_then(|v| v.as_u64())
            .unwrap_or(200) as usize;
        // Try ripgrep, fallback to grep -R
        let try_rg = Command::new("rg")
            .arg("-n")
            .arg("--no-heading")
            .arg("--color")
            .arg("never")
            .arg(pattern)
            .arg(root)
            .output()
            .await;
        let output = match try_rg {
            Ok(o) => o,
            Err(_) => {
                Command::new("grep")
                    .arg("-R")
                    .arg("-n")
                    .arg(pattern)
                    .arg(root)
                    .output()
                    .await?
            }
        };
        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let mut lines: Vec<&str> = stdout.lines().collect();
        let trimmed = lines.len().saturating_sub(max_results);
        if lines.len() > max_results {
            lines.truncate(max_results);
        }
        let mut out = lines.join("\n");
        if trimmed > 0 {
            out.push_str(&format!("\n... trimmed {} more matches", trimmed));
        }
        Ok(out)
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

// Edit file using unified diff
pub struct EditFileTool;

#[async_trait]
impl ToolExecutor for EditFileTool {
    fn name(&self) -> &str {
        "edit_file"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path"))?;
        let diff = params["diff"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing diff"))?;
        let original = tokio::fs::read_to_string(path).await?;
        let new = apply_unified_diff(&original, diff)?;
        tokio::fs::write(path, new).await?;
        Ok("ok".into())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

fn apply_unified_diff(original: &str, diff: &str) -> Result<String> {
    use regex::Regex;
    let lines: Vec<String> = original.split('\n').map(|s| s.to_string()).collect();
    let re_hunk = Regex::new(r"^@@ -([0-9]+)(?:,([0-9]+))? \+([0-9]+)(?:,([0-9]+))? @@").unwrap();
    // skip headers --- +++ if present
    let mut iter = diff.lines().peekable();
    while let Some(line) = iter.peek() {
        if line.starts_with("--- ") || line.starts_with("+++ ") {
            iter.next();
        } else {
            break;
        }
    }
    let mut output: Vec<String> = Vec::new();
    let mut src_index = 0usize; // 0-based in our buffer
    while let Some(line) = iter.next() {
        if let Some(caps) = re_hunk.captures(line) {
            let old_start: usize = caps.get(1).unwrap().as_str().parse().unwrap();
            // let old_count = caps.get(2).map(|m| m.as_str().parse::<usize>().unwrap()).unwrap_or(1);
            // Append unchanged lines before the hunk
            let target_index = old_start.saturating_sub(1);
            while src_index < target_index {
                output.push(lines[src_index].clone());
                src_index += 1;
            }
            // Now consume hunk lines until next hunk or EOF
            while let Some(next) = iter.peek() {
                let c = next.as_bytes().get(0).copied().unwrap_or(b' ');
                if c == b'@' {
                    break;
                }
                let l = iter.next().unwrap();
                match c {
                    b' ' => {
                        // context
                        let ctx = &l[1..];
                        if src_index >= lines.len() || lines[src_index] != ctx {
                            anyhow::bail!("context mismatch applying diff");
                        }
                        output.push(lines[src_index].clone());
                        src_index += 1;
                    }
                    b'-' => {
                        // removal
                        let old = &l[1..];
                        if src_index >= lines.len() || lines[src_index] != old {
                            anyhow::bail!("deletion mismatch applying diff");
                        }
                        src_index += 1;
                    }
                    b'+' => {
                        // addition
                        output.push(l[1..].to_string());
                    }
                    _ => {}
                }
            }
        }
    }
    // append remainder
    while src_index < lines.len() {
        output.push(lines[src_index].clone());
        src_index += 1;
    }
    Ok(output.join("\n"))
}

pub struct DeleteFileTool;

#[async_trait]
impl ToolExecutor for DeleteFileTool {
    fn name(&self) -> &str {
        "delete_file"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path"))?;
        // Copy to backup store for easy undelete
        let backups = SessionStore::backups_dir();
        tokio::fs::create_dir_all(&backups).await.ok();
        let file_name = std::path::Path::new(path)
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or("file");
        let backup_path = backups.join(format!(
            "{}-{}",
            file_name,
            time::OffsetDateTime::now_utc().unix_timestamp()
        ));
        // Best-effort copy; if it fails, proceed with trash anyway
        let _ = tokio::fs::copy(path, &backup_path).await;
        if backup_path.exists() {
            let _ = SessionStore::record_deleted(path, &backup_path.to_string_lossy());
        }
        trash::delete(path)?;
        Ok(format!("moved to recycle bin: {}", path))
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct UndeleteFileTool;

#[async_trait]
impl ToolExecutor for UndeleteFileTool {
    fn name(&self) -> &str {
        "undelete_file"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path"))?;
        if let Some(backup) = SessionStore::pop_latest_deleted(path)? {
            let parent = std::path::Path::new(path)
                .parent()
                .map(|p| p.to_path_buf())
                .unwrap_or_else(|| std::path::PathBuf::from("."));
            tokio::fs::create_dir_all(&parent).await.ok();
            tokio::fs::copy(&backup, path).await?;
            // remove backup file; ignore errors
            let _ = tokio::fs::remove_file(&backup).await;
            Ok(format!("restored {}", path))
        } else {
            anyhow::bail!("no backup found for {}", path)
        }
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct GitStatusTool;

#[async_trait]
impl ToolExecutor for GitStatusTool {
    fn name(&self) -> &str {
        "git_status"
    }
    async fn execute(&self, _args: &str) -> Result<String> {
        let out = Command::new("git")
            .arg("status")
            .arg("--porcelain")
            .output()
            .await?;
        Ok(String::from_utf8_lossy(&out.stdout).into_owned())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct GitDiffTool;

#[async_trait]
impl ToolExecutor for GitDiffTool {
    fn name(&self) -> &str {
        "git_diff"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let rev = params.get("rev").and_then(|v| v.as_str()).unwrap_or("HEAD");
        let path = params.get("path").and_then(|v| v.as_str());
        let mut cmd = Command::new("git");
        cmd.arg("diff").arg(rev);
        if let Some(p) = path {
            cmd.arg("--").arg(p);
        }
        let out = cmd.output().await?;
        Ok(String::from_utf8_lossy(&out.stdout).into_owned())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct GitApplyTool;

#[async_trait]
impl ToolExecutor for GitApplyTool {
    fn name(&self) -> &str {
        "git_apply"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let diff = params["diff"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing diff"))?;
        let mut child = Command::new("git")
            .arg("apply")
            .arg("--whitespace=nowarn")
            .arg("-p0")
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .spawn()?;
        if let Some(stdin) = child.stdin.as_mut() {
            use tokio::io::AsyncWriteExt;
            stdin.write_all(diff.as_bytes()).await?;
        }
        let out = child.wait_with_output().await?;
        if !out.status.success() {
            anyhow::bail!(String::from_utf8_lossy(&out.stderr).to_string());
        }
        Ok("applied".into())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct HttpGetTool;

#[async_trait]
impl ToolExecutor for HttpGetTool {
    fn name(&self) -> &str {
        "http_get"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let url = params["url"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing url"))?;
        let max = params
            .get("max_bytes")
            .and_then(|v| v.as_u64())
            .unwrap_or(256 * 1024) as usize;
        let client = reqwest::Client::new();
        let resp = client.get(url).send().await?;
        let mut stream = resp.bytes_stream();
        let mut out = Vec::new();
        use futures_util::TryStreamExt;
        while let Some(chunk) = stream.try_next().await? {
            if out.len() >= max {
                break;
            }
            let n = std::cmp::min(max - out.len(), chunk.len());
            out.extend_from_slice(&chunk[..n]);
            if out.len() >= max {
                break;
            }
        }
        Ok(String::from_utf8_lossy(&out).into_owned())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct HttpPostTool;

#[async_trait]
impl ToolExecutor for HttpPostTool {
    fn name(&self) -> &str {
        "http_post"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let url = params["url"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing url"))?;
        let body = params["body"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing body"))?;
        let content_type = params
            .get("content_type")
            .and_then(|v| v.as_str())
            .unwrap_or("application/json");
        let max = params
            .get("max_bytes")
            .and_then(|v| v.as_u64())
            .unwrap_or(256 * 1024) as usize;
        let client = reqwest::Client::new();
        let resp = client
            .post(url)
            .header("Content-Type", content_type)
            .body(body.to_string())
            .send()
            .await?;
        let mut stream = resp.bytes_stream();
        let mut out = Vec::new();
        use futures_util::TryStreamExt;
        while let Some(chunk) = stream.try_next().await? {
            if out.len() >= max {
                break;
            }
            let n = std::cmp::min(max - out.len(), chunk.len());
            out.extend_from_slice(&chunk[..n]);
            if out.len() >= max {
                break;
            }
        }
        Ok(String::from_utf8_lossy(&out).into_owned())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct FileInfoTool;

#[async_trait]
impl ToolExecutor for FileInfoTool {
    fn name(&self) -> &str {
        "file_info"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path"))?;
        let meta = tokio::fs::metadata(path).await?;
        let size = meta.len();
        let is_dir = meta.is_dir();
        Ok(json!({"path": path, "size": size, "is_dir": is_dir}).to_string())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ChecksumTool;

#[async_trait]
impl ToolExecutor for ChecksumTool {
    fn name(&self) -> &str {
        "checksum"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path"))?;
        let data = tokio::fs::read(path).await?;
        let mut hasher = Sha256::new();
        hasher.update(&data);
        let hex = format!("{:x}", hasher.finalize());
        Ok(json!({"algorithm":"sha256","hex":hex}).to_string())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct JsonQueryTool;

#[async_trait]
impl ToolExecutor for JsonQueryTool {
    fn name(&self) -> &str {
        "json_query"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path"))?;
        let pointer = params["pointer"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing pointer"))?;
        let text = tokio::fs::read_to_string(path).await?;
        let v: Value = serde_json::from_str(&text)?;
        let res = v.pointer(pointer).cloned().unwrap_or(Value::Null);
        Ok(res.to_string())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct YamlQueryTool;

#[async_trait]
impl ToolExecutor for YamlQueryTool {
    fn name(&self) -> &str {
        "yaml_query"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params["path"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing path"))?;
        let pointer = params["pointer"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing pointer"))?;
        let text = tokio::fs::read_to_string(path).await?;
        let y: serde_yaml::Value = serde_yaml::from_str(&text)?;
        let v: Value = serde_json::to_value(y)?;
        let res = v.pointer(pointer).cloned().unwrap_or(Value::Null);
        Ok(res.to_string())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct CargoTool;

#[async_trait]
impl ToolExecutor for CargoTool {
    fn name(&self) -> &str {
        "run_cargo"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let args = params["args"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing args"))?;
        let parts: Vec<String> = shlex::Shlex::new(args).collect();
        let out = Command::new("cargo").args(&parts).output().await?;
        Ok(format!(
            "status:{}\nstdout:\n{}\nstderr:\n{}",
            out.status.code().unwrap_or(-1),
            String::from_utf8_lossy(&out.stdout),
            String::from_utf8_lossy(&out.stderr)
        ))
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct GitCommitTool;

#[async_trait]
impl ToolExecutor for GitCommitTool {
    fn name(&self) -> &str {
        "git_commit"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let message = params["message"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing message"))?;
        let add_all = params
            .get("add_all")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);
        if add_all {
            let out = Command::new("git").arg("add").arg("-A").output().await?;
            if !out.status.success() {
                anyhow::bail!(String::from_utf8_lossy(&out.stderr).to_string());
            }
        }
        let out = Command::new("git")
            .arg("commit")
            .arg("-m")
            .arg(message)
            .output()
            .await?;
        if !out.status.success() {
            anyhow::bail!(String::from_utf8_lossy(&out.stderr).to_string());
        }
        Ok(String::from_utf8_lossy(&out.stdout).into_owned())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct GitBranchTool;

#[async_trait]
impl ToolExecutor for GitBranchTool {
    fn name(&self) -> &str {
        "git_branch"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let action = params["action"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing action"))?;
        match action {
            "current" => {
                let out = Command::new("git")
                    .args(["rev-parse", "--abbrev-ref", "HEAD"])
                    .output()
                    .await?;
                Ok(String::from_utf8_lossy(&out.stdout).trim().to_string())
            }
            "list" => {
                let out = Command::new("git")
                    .args(["branch", "--list"])
                    .output()
                    .await?;
                Ok(String::from_utf8_lossy(&out.stdout).into_owned())
            }
            "switch" => {
                let name = params["name"]
                    .as_str()
                    .ok_or_else(|| anyhow::anyhow!("Missing name for switch"))?;
                let out = Command::new("git").args(["switch", name]).output().await?;
                if !out.status.success() {
                    anyhow::bail!(String::from_utf8_lossy(&out.stderr).to_string());
                }
                Ok(format!("switched to {}", name))
            }
            "create" => {
                let name = params["name"]
                    .as_str()
                    .ok_or_else(|| anyhow::anyhow!("Missing name for create"))?;
                let out = Command::new("git")
                    .args(["switch", "-c", name])
                    .output()
                    .await?;
                if !out.status.success() {
                    anyhow::bail!(String::from_utf8_lossy(&out.stderr).to_string());
                }
                Ok(format!("created and switched to {}", name))
            }
            other => anyhow::bail!(format!(
                "unknown action: {} (use current|list|switch|create)",
                other
            )),
        }
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct FormatRustTool;

#[async_trait]
impl ToolExecutor for FormatRustTool {
    fn name(&self) -> &str {
        "format_rust"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let path = params.get("path").and_then(|v| v.as_str());
        let out = if let Some(p) = path {
            Command::new("rustfmt").arg(p).output().await?
        } else {
            Command::new("cargo").arg("fmt").output().await?
        };
        Ok(format!(
            "status:{}\nstderr:\n{}",
            out.status.code().unwrap_or(-1),
            String::from_utf8_lossy(&out.stderr)
        ))
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ZipTool;

#[async_trait]
impl ToolExecutor for ZipTool {
    fn name(&self) -> &str {
        "zip"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let input = params["input"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing input"))?;
        let output = params["output"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing output"))?;
        let input_s = input.to_string();
        let output_s = output.to_string();
        let output_report = output_s.clone();
        tokio::task::spawn_blocking(move || {
            let path = std::path::Path::new(&input_s);
            let file = std::fs::File::create(&output_s)?;
            let mut zip = zip::ZipWriter::new(file);
            let options = zip::write::FileOptions::default()
                .compression_method(zip::CompressionMethod::Deflated);
            if path.is_dir() {
                let walker = walkdir::WalkDir::new(&path).into_iter();
                let base = path;
                for entry in walker.flatten() {
                    let p = entry.path();
                    if p.is_dir() {
                        continue;
                    }
                    let rel = p.strip_prefix(base).unwrap();
                    let rel_str = rel.to_string_lossy().replace('\\', "/");
                    zip.start_file(rel_str, options)?;
                    let bytes = std::fs::read(p)?;
                    zip.write_all(&bytes)?;
                }
            } else {
                let name = path.file_name().and_then(|s| s.to_str()).unwrap_or("file");
                zip.start_file(name, options)?;
                let bytes = std::fs::read(path)?;
                zip.write_all(&bytes)?;
            }
            zip.finish()?;
            anyhow::Ok(())
        })
        .await??;
        Ok(format!("created {}", output_report))
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct UnzipTool;

#[async_trait]
impl ToolExecutor for UnzipTool {
    fn name(&self) -> &str {
        "unzip"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let archive = params["archive"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing archive"))?;
        let out_dir = params["output_dir"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing output_dir"))?;
        let archive_s = archive.to_string();
        let out_dir_s = out_dir.to_string();
        let out_report = out_dir_s.clone();
        tokio::task::spawn_blocking(move || {
            let file = std::fs::File::open(&archive_s)?;
            let mut zip = zip::ZipArchive::new(file)?;
            std::fs::create_dir_all(&out_dir_s)?;
            for i in 0..zip.len() {
                let mut f = zip.by_index(i)?;
                let outpath = std::path::Path::new(&out_dir_s).join(f.mangled_name());
                if f.is_dir() {
                    std::fs::create_dir_all(&outpath)?;
                    continue;
                }
                if let Some(parent) = outpath.parent() {
                    std::fs::create_dir_all(parent)?;
                }
                let mut outfile = std::fs::File::create(&outpath)?;
                std::io::copy(&mut f, &mut outfile)?;
            }
            anyhow::Ok(())
        })
        .await??;
        Ok(format!("extracted to {}", out_report))
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ListDeletedTool;

#[async_trait]
impl ToolExecutor for ListDeletedTool {
    fn name(&self) -> &str {
        "list_deleted"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args).unwrap_or(json!({}));
        let limit = params.get("limit").and_then(|v| v.as_u64()).unwrap_or(50) as usize;
        let rows = SessionStore::list_deleted(limit)?;
        let mut out = String::new();
        for (path, ts) in rows {
            out.push_str(&format!("{}\t{}\n", ts, path));
        }
        Ok(out)
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct DbQueryTool;

#[async_trait]
impl ToolExecutor for DbQueryTool {
    fn name(&self) -> &str {
        "db_query"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let sql = params["sql"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing sql"))?;
        if !sql.trim_start().to_lowercase().starts_with("select") {
            anyhow::bail!("only SELECT queries are allowed");
        }
        let conn = SessionStore::conn_ro()?;
        let mut stmt = conn.prepare(sql)?;
        let col_names: Vec<String> = stmt
            .column_names()
            .into_iter()
            .map(|s| s.to_string())
            .collect();
        let col_len = col_names.len();
        let binds: Vec<serde_json::Value> = params
            .get("params")
            .and_then(|v| v.as_array())
            .cloned()
            .unwrap_or_default();
        let rows = stmt.query_map(
            rusqlite::params_from_iter(binds.iter().map(|v| json_to_sql(v))),
            move |row| {
                let mut obj = serde_json::Map::new();
                for i in 0..col_len {
                    let name = col_names[i].clone();
                    let val = sql_value_to_json(row, i);
                    obj.insert(name, val);
                }
                Ok(serde_json::Value::Object(obj))
            },
        )?;
        let mut out = Vec::new();
        for r in rows {
            out.push(r?);
        }
        Ok(serde_json::Value::Array(out).to_string())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

fn json_to_sql(v: &serde_json::Value) -> rusqlite::types::Value {
    use rusqlite::types::Value as SV;
    match v {
        serde_json::Value::Null => SV::Null,
        serde_json::Value::Bool(b) => SV::Integer(if *b { 1 } else { 0 }),
        serde_json::Value::Number(n) => {
            if let Some(i) = n.as_i64() {
                SV::Integer(i)
            } else if let Some(f) = n.as_f64() {
                SV::Real(f)
            } else {
                SV::Null
            }
        }
        serde_json::Value::String(s) => SV::Text(s.clone()),
        other => SV::Text(other.to_string()),
    }
}

fn sql_value_to_json(row: &rusqlite::Row<'_>, idx: usize) -> serde_json::Value {
    use rusqlite::types::ValueRef;
    match row.get_ref(idx) {
        Ok(ValueRef::Null) => serde_json::Value::Null,
        Ok(ValueRef::Integer(i)) => serde_json::Value::from(i),
        Ok(ValueRef::Real(r)) => serde_json::Value::from(r),
        Ok(ValueRef::Text(t)) => serde_json::Value::from(String::from_utf8_lossy(t).to_string()),
        Ok(ValueRef::Blob(_)) => serde_json::Value::String("<blob>".into()),
        Err(_) => serde_json::Value::Null,
    }
}

pub struct AddNoteTool;

#[async_trait]
impl ToolExecutor for AddNoteTool {
    fn name(&self) -> &str {
        "add_note"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args)?;
        let content = params["content"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing content"))?;
        let title = params.get("title").and_then(|v| v.as_str());
        let tags = params.get("tags").and_then(|v| v.as_str());
        let conn = SessionStore::conn_rw()?;
        let now = time::OffsetDateTime::now_utc()
            .format(&time::format_description::well_known::Rfc3339)
            .unwrap_or_else(|_| "".into());
        conn.execute(
            "INSERT INTO notes (title, content, tags, created_at, updated_at) VALUES (?1, ?2, ?3, ?4, ?5)",
            rusqlite::params![title, content, tags, now, now],
        )?;
        let id = conn.last_insert_rowid();
        Ok(serde_json::json!({"id": id}).to_string())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ListNotesTool;

#[async_trait]
impl ToolExecutor for ListNotesTool {
    fn name(&self) -> &str {
        "list_notes"
    }
    async fn execute(&self, args: &str) -> Result<String> {
        let params: Value = serde_json::from_str(args).unwrap_or(json!({}));
        let limit = params.get("limit").and_then(|v| v.as_u64()).unwrap_or(50) as i64;
        let search = params.get("search").and_then(|v| v.as_str());
        let conn = SessionStore::conn_ro()?;
        let mut out = Vec::new();
        if let Some(q) = search {
            let mut stmt = conn.prepare("SELECT id, title, substr(content,1,200) as snippet, tags, created_at, updated_at FROM notes WHERE title LIKE ?1 OR content LIKE ?1 ORDER BY id DESC LIMIT ?2")?;
            let rows = stmt.query_map(rusqlite::params![format!("%{}%", q), limit], |r| {
                Ok(serde_json::json!({
                    "id": r.get::<_, i64>(0)?,
                    "title": r.get::<_, Option<String>>(1)?,
                    "snippet": r.get::<_, Option<String>>(2)?,
                    "tags": r.get::<_, Option<String>>(3)?,
                    "created_at": r.get::<_, String>(4)?,
                    "updated_at": r.get::<_, String>(5)?,
                }))
            })?;
            for r in rows {
                out.push(r?);
            }
        } else {
            let mut stmt = conn.prepare("SELECT id, title, substr(content,1,200) as snippet, tags, created_at, updated_at FROM notes ORDER BY id DESC LIMIT ?1")?;
            let rows = stmt.query_map(rusqlite::params![limit], |r| {
                Ok(serde_json::json!({
                    "id": r.get::<_, i64>(0)?,
                    "title": r.get::<_, Option<String>>(1)?,
                    "snippet": r.get::<_, Option<String>>(2)?,
                    "tags": r.get::<_, Option<String>>(3)?,
                    "created_at": r.get::<_, String>(4)?,
                    "updated_at": r.get::<_, String>(5)?,
                }))
            })?;
            for r in rows {
                out.push(r?);
            }
        }
        Ok(serde_json::Value::Array(out).to_string())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}
